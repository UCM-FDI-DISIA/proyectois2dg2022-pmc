package logic;

import java.util.ArrayList;
import java.util.List;

<<<<<<< HEAD
import Rolit.Controller;
import Rolit.SaveLoadManager;
import utils.StringUtils;
import org.json.JSONObject;
=======
import org.json.JSONObject;

>>>>>>> a4e6a35 (Creados metodos save/loadReplay en el SaveLoadManager)
public class Board implements Replayable{
	
	public final static int MAX_SIZE = 15;

	private List<List<Cube>> matrix;
	private int[][] shape;
	private int size;
	private int numCubes;

	private static final String SPACE = " ";
	
	public Board(int size, Shape shape) {
		this.numCubes = 0;
		this.matrix = new ArrayList<List<Cube>>();
		this.shape = SaveLoadManager.loadShape(shape.getFilename());
		//aqui se llamara a una funcion que cargue la mtriz de booleanos
		for (int i = 0; i < size; i++) {
			this.matrix.add(new ArrayList<Cube>(size));
		}

		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				List<Cube> column = matrix.get(i);
				column.add(null);
			}
		}
	}

	public int getSize() {
		return size;
	}

	public Cube getCubeInPos(int x, int y) {
		return matrix.get(x).get(y);
	}

	public void addCubeInPos(Cube c) {
		List<Cube> column = matrix.get(c.getX());
		column.remove(c.getY());
		column.add(c.getY(), c);
		c.addPlayerScore();
		this.numCubes++;
	}

	public int getNumCubes() {
		return numCubes;
	}

	public boolean isBoardFull() {
		return numCubes == size * size;
	}

	public void update(Cube newCube) {
		int posX = newCube.getX(), posY = newCube.getY();
		int newX, newY;
		int foundX = posX, foundY = posY; // Las inicializo porque si no Eclipse se queja
		boolean found;
		Cube currentCube;

		// Hacemos dos bucles para indicar la direccion en la que vamos a buscar un cubo
		// del color del jugador actual
		// Estos dos bucles representan siempre 8 iteraciones, por lo que no implican
		// que el coste del algoritmo sea cubico (es lineal)
		for (int dirX = -1; dirX <= 1; dirX++) {
			for (int dirY = -1; dirY <= 1; dirY++) {
				// Partiendo de la posicion actual (posX, posY), nos movemos en la direccion
				// actual
				// sumando a la posicion actual (dirX, dirY)
				if (!(dirX == 0 && dirY == 0)) {
					newX = posX + dirX;
					newY = posY + dirY;
					found = false;
					boolean conected = true;
					// Comprobamos la nueva casilla y el posible cubo que haya en ella
					while (isPositionInRange(newX, newY) && !found && conected) {
						currentCube = getCubeInPos(newX, newY);
						if (currentCube != null) {
							// Si el cubo es del color del jugador actual dejamos de buscar, es hasta este
							// hasta el que tenemos que llegar
							if (currentCube.getColor().equals(newCube.getColor())) {
								found = true;
								foundX = newX;
								foundY = newY;
							}
							// Si el cubo es de otro color seguimos buscando
							else {
								newX += dirX;
								newY += dirY;
							}
						} else {
							conected = false; // Si hay alguna casilla vacia en esta direccion dejamos de buscar
						}
					}
					// Si en la direccion dada por (dirX, dirY) hemos encontrado otro cubo del color
					// del jugador actual
					// ponemos cubos del color en cuestion en todas las casillas entre medias
					if (found) {
						newX = posX + dirX;
						newY = posY + dirY;
						while (!(newX == foundX && newY == foundY)) {
							currentCube = getCubeInPos(newX, newY);

							// Cambiamos de color el cubo en cuestion al color del jugador actual y actualizamos los puntos
							currentCube.changeOwner(newCube.getColor());
							
							newX += dirX;
							newY += dirY;
						}
					}
				}
			}
		}
		
	}
	
	public String positionToString(int x, int y) {
		Cube cube = getCubeInPos(x, y);
		if (cube == null)
			return " ";
		else
			return cube.getColor().toString();
	}
	
	@Override
	public String toString() {
		StringBuilder str = new StringBuilder();
		str.append(StringUtils.LINE_SEPARATOR);
		// Paint game
		for (int x = 0; x < size + 2; x++) {
			for (int y = 0; y < size + 2; y++) {
				if (shape[x][y] == 1) str.append("X").append(SPACE);
				else if (shape[x][y] == 2) str.append(positionToString(x, y)).append(SPACE);
			}
			str.append(StringUtils.LINE_SEPARATOR);
			
		}
		str.append(StringUtils.LINE_SEPARATOR);
		
		return str.toString();
	}

	private boolean isPositionInRange(int x, int y) {
		return x >= 0 && x < size && y >= 0 && y < size && shape[x + 1][y + 1] == 2;
	}
	
	public boolean tryToAddCube(int x, int y) {
		if (numCubes > 0) {
			boolean nearbyCube = false;
			if (!isPositionInRange(x, y) || getCubeInPos(x, y) != null)
				return false;
			for (int i = -1; i <= 1; i++) {
				for (int j = -1; j <= 1; j++) {
					if (isPositionInRange(x + i, y + j) && getCubeInPos(x + i, y + j) != null) {
						nearbyCube = true;
					}
				}
			}
			return nearbyCube;
		} else
			return isPositionInRange(x, y);
	}

	@Override
	public JSONObject report() {
		JSONObject jo = new JSONObject();
		
		JSONArray jo1 = new JSONArray();
		for (int i =0; i<matrix.size() ;i++)
			for (int j=0; j< matrix.get(i).size(); j++)
				jo1.put(getCubeInPos(i,j).report());
		
		jo.put("size", (Integer)size);
		jo.put("cubes", jo1);
		// TODO Auto-generated method stub
		return jo;
	}

}
